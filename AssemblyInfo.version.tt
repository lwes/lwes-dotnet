<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" language="C#v3.5" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ Assembly Name="System.Xml"#>
<#@ Assembly Name="System.Xml.Linq"#>
<#@ Assembly Name="System.Windows.Forms"#>
<#@ Assembly Name="EnvDTE"#>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#
// get VisualStudio IDE 
EnvDTE.DTE theDTE = (EnvDTE.DTE)System.Runtime.InteropServices.Marshal.
                        GetActiveObject("VisualStudio.DTE.9.0"); 
// get TT-file
var ttFile = this.Host.TemplateFile;
var versioningFileName = @"..\Versioning.xml";

// get project containing TT-file
var prjItem = theDTE.Solution.FindProjectItem(ttFile);
var prjFolder = Path.GetDirectoryName(prjItem.ContainingProject.FileName);
var solutionFolder = Path.GetDirectoryName(theDTE.Solution.FileName);

var resolvedVersioningFile = (File.Exists(Path.Combine(prjFolder, versioningFileName))) 
	? Path.Combine(prjFolder, versioningFileName)
	: Path.Combine(solutionFolder, versioningFileName);
	
var MajorVersion = "0";
var MinorVersion = "1";
var BuildNumber = "*";
var RevisionNumber = "";
var PrintVersion = new Func<string>(() =>
		{
			var buildAndRevision = (string.Equals(BuildNumber, "*")) ? BuildNumber : string.Concat(BuildNumber, '.', RevisionNumber);
			return string.Concat(MajorVersion, '.', MinorVersion, '.', buildAndRevision);
		});
			
if (File.Exists(resolvedVersioningFile))
{
	var vdoc = XDocument.Load(resolvedVersioningFile);
	MajorVersion = GetValueAndResolve(vdoc.Root, "major", MajorVersion, prjFolder);
	MinorVersion = GetValueAndResolve(vdoc.Root, "minor", MinorVersion, prjFolder);
	BuildNumber = GetValueAndResolve(vdoc.Root, "build", BuildNumber, prjFolder);
	RevisionNumber = GetValueAndResolve(vdoc.Root, "revision", RevisionNumber, prjFolder);
}


#>
using System.Reflection; 

[assembly: AssemblyVersion("<#= PrintVersion() #>")]
<#+ string GetValueAndResolve(XElement elm, string name, string value, string prjFolder) 
{ 
	string result = value;
	var e = (XElement)(from elem in elm.Descendants(name) select elem).Single();
	if (e != null && !String.IsNullOrEmpty(e.Value))
		result = e.Value;
	if (String.Equals("$(svn.revision)", result)) 
	{
		// HACK! The .svn/entries file does not have a published format so this code
		// may break at any time if subversion itself changes the format.
	  var svnFolder = Path.Combine(prjFolder, ".svn");
	  if (Directory.Exists(svnFolder))
	  {
	  	using (var reader = new StreamReader(Path.Combine(svnFolder, "entries")))
		{
			// Fields are delimited by a newline character...
			string[] inp = reader.ReadToEnd().Split('\n');
			// the revision is the 3rd field
			if (inp.Length > 3)
				return inp[3];
		}
	  }
	  else return "no svn folder found";	  
	}
	else if (String.Equals("$(seconds)", result))
	{
		var now = DateTime.Now;
		var secondsSinceMidnight = Convert.ToInt32(now.Subtract(new DateTime(now.Year, now.Month, now.Day, 0, 0, 0, 0)).TotalSeconds);
		result = (secondsSinceMidnight == 0) ? "0" : Convert.ToInt32(secondsSinceMidnight / 2).ToString();
	}
	return result;
} #>
